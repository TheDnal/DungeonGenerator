using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class RoomDistributor : MonoBehaviour
{
    public enum roomDistributionType
    {
        RANDOM,
        ACCRETION,
        BSP
    }
    public static RoomDistributor instance;
    private int roomCount = 5;
    private int seed = 0;
    private int accretionMaxRange = 1,accretionMinRange = 5;
    private roomDistributionType type;
    private List<Tile> tiles = new List<Tile>();
    private List<Tile> roomCentres = new List<Tile>();
    private List<Room> rooms = new List<Room>();
    void Awake()
    {
        if(instance != null)
        {
            if(instance != this)
            {
                Destroy(this);
            }
        }
        instance = this;
    }
    #region Setters
    public void SetDistributionType(int _typeIndex)
    {
        type = (roomDistributionType)_typeIndex;
        Generate();
    }
    public void SetRoomCount(int _count)
    {
        roomCount = _count;
        Generate();
    }
    public void SetSeed(int _seed)
    {
        seed = _seed;
        Generate();
    }
    public void SetAccretionMaxRange(int _maxRange)
    {
        accretionMaxRange = _maxRange;
        Generate();
    }
    public void SetAccretionMinRange(int _minRange)
    {
        accretionMinRange = _minRange;
        Generate();
    }
    #endregion
    public List<Room> GetRooms(){return rooms;}
    private void Generate()
    {
        TileGrid.instance.ClearAllRooms();
        tiles = TileGrid.instance.GetUnsortedTiles();
        roomCentres.Clear();
        rooms.Clear();
        switch(type)
        {
            case roomDistributionType.RANDOM:
                int successfulRooms = 0;
                while(tiles.Count > 0 && successfulRooms != roomCount)
                {
                    Tile newRoomCentre = TryCreateRoomCentre(successfulRooms);
                    if(newRoomCentre != null)
                    {
                        roomCentres.Add(newRoomCentre);
                        Room newRoom = new Room(newRoomCentre);
                        rooms.Add(newRoom);
                        if(successfulRooms > 0)
                        {
                            newRoom.ConnectRoom(rooms[successfulRooms - 1]);
                        }
                        successfulRooms++;
                    }

                }
                break;
            case roomDistributionType.ACCRETION:
                Debug.Log("starting accretion");
                GenerateAccretion(roomCount);
                break;
            case roomDistributionType.BSP:
                PartitionAxes newAxis = new PartitionAxes(Vector2.up * 10, true);
                Partition p = new Partition(null,null,newAxis);
                List<Tile> partitionTiles = p.GetTilesInParitition();
                foreach(Tile tile in partitionTiles)
                {
                    tile.PaintTile(Tile.TileType.room);
                }
                break;
        }
    }
    
    private Tile TryCreateRoomCentre(int _currRoomCount)
    {
        Random.seed = seed;
        int index = Random.Range(0,tiles.Count);
        List<Tile> potentialRoom = tiles[index].GetNeighbours(true);
        potentialRoom.Add(tiles[index]);
        foreach(Tile tile in potentialRoom)
        {
            if(tile.type != Tile.TileType.blank)
            {
                RemoveTilesFromCache(potentialRoom);
                return null;
            }
        }
        // foreach(Tile tile in potentialRoom)
        // {
        //     // float a =_currRoomCount;
        //     // float b = roomCount;
        //     // Color col = Color.Lerp(Color.white,Color.yellow, a / b);
        //     // tile.PaintTile(Tile.TileType.room);
        // }
        tiles[index].PaintTile(Tile.TileType.room);
        return tiles[index];
    }
    private Partition GenerateBinarySpacialPartition()
    {
        return null;
    }
    #region RoomAccretion
    private void GenerateAccretion(int _MaxRoomCount, int _maxTriesPerRoom = 5)
    {
        //Room accretion is the method by which new rooms are generated by "offshooting" them from its old rooms.
        //This process is repeated until no rooms have space to generate offshoots or the number of desired rooms
        //has been reached
        //This will be started by creating the first room at random and then repeating the accretion process until
        //the prior conditions have been met

        Tile RootRoomRootTile = null;
        int index = 0; //prevents infinite loop
        while(RootRoomRootTile == null)
        {
            RootRoomRootTile = TryCreateRoomCentre(0);
            index ++;
            if(index > 100){return;}
        }
        int roomCount = 0;
        Room rootRoom = new Room(RootRoomRootTile);
        rooms.Add(rootRoom);
        //Create list of valid rooms that can offshoot new rooms
        List<Room> ValidAccretionRooms = new List<Room>();
        ValidAccretionRooms.Add(rootRoom);
        int counter = 0; //prevents infinite loops
        while(rooms.Count < _MaxRoomCount && ValidAccretionRooms.Count > 0)
        {
            counter ++;
            if(counter > 100)
            {
                Debug.Log("room accretion forced stop after 100 iterations");
                return;
            }
            //Get current Room to accrete
            Room currRoom = ValidAccretionRooms[ValidAccretionRooms.Count - 1];
            //Try and generate new roomcentre
            Tile newRoomCentre = null;
            for(int i = 0; i < _maxTriesPerRoom; i ++)
            {
                newRoomCentre = TryAccreteRoom(currRoom,accretionMaxRange,accretionMinRange);
                if(newRoomCentre != null){i = 1000;}
            }
            if(newRoomCentre == null) //If failed, remove the current room from valid list
            {
                Debug.Log("failed to accrete new room");
                ValidAccretionRooms.Remove(currRoom);
            }
            else    //if succeeded, add new room
            {
                Debug.Log("new room accreted");
                Room newRoom = new Room(newRoomCentre);
                newRoomCentre.PaintTile(Tile.TileType.room);
                //Connect old room to child room
                currRoom.ConnectRoom(newRoom);
                ValidAccretionRooms.Add(newRoom);
                rooms.Add(newRoom);
            }

            if(rooms.Count >= _MaxRoomCount){Debug.Log("room count reached");}
            else if(ValidAccretionRooms.Count <= 0){Debug.Log("ran out of valid rooms");}
        }
    }
    private Tile TryAccreteRoom(Room _rootRoom,int _accretionMaxRadius, int _accretionMinRadius)
    {
        List<Tile> validTiles = new List<Tile>();
        Vector2Int cornerOffset = new Vector2Int(-1,-1) * _accretionMaxRadius / 2;
        Vector2Int dimensions = new Vector2Int(1,1) * (_accretionMaxRadius + 1);
        validTiles = TileGrid.instance.GetTilesInRegion(_rootRoom.rootTile.GetCoords() + cornerOffset,dimensions);
        
        List<Tile> invalidTiles = new List<Tile>();
        cornerOffset = new Vector2Int(-1,-1) * _accretionMinRadius/2;
        dimensions = new Vector2Int(1,1) * (_accretionMinRadius + 1);
        invalidTiles = TileGrid.instance.GetTilesInRegion(_rootRoom.rootTile.GetCoords() + cornerOffset, dimensions);
        foreach(Tile invalidTile in invalidTiles)
        {
            if(validTiles.Contains(invalidTile))
            {
                validTiles.Remove(invalidTile);
            }
        }
        if(validTiles.Count == 0){return null;}
        int rndIndex = Random.Range(0,validTiles.Count);
        foreach(Tile neighbour in validTiles[rndIndex].GetNeighbours())
        {
            if(neighbour.type == Tile.TileType.room){return null;}
        }
        if(validTiles[rndIndex].type == Tile.TileType.blank){return validTiles[rndIndex];}
        return null;
    }
    #endregion
    private void RemoveTilesFromCache(List<Tile> _tilesToRemove)
    {
        foreach(Tile tile in _tilesToRemove)
        {
            if(!tiles.Contains(tile)){continue;}
            tiles.Remove(tile);
        }
    }

    void OnDrawGizmos()
    {
        if(rooms == null){return;}
        if(rooms.Count < 1){return;}
        foreach(Room currRoom in rooms)
        {
            if(currRoom.GetConnectedRooms().Count < 1){continue;}
            foreach(Room connectedRoom in currRoom.GetConnectedRooms())
            {
                if(connectedRoom == null){continue;}
                Gizmos.color = Color.red;
                Gizmos.DrawLine(currRoom.rootTile.transform.position,connectedRoom.rootTile.transform.position);
            }
        }
    }
}

public class Partition
{
    public Partition parentPartition = null;
    public List<Partition> childPartitions = new List<Partition>();
    public PartitionAxes partitionAxes;
    public Partition(Partition _parent, List<Partition> _children, PartitionAxes _partitionAxes)
    {
        parentPartition = _parent;
        childPartitions = _children;
        if(childPartitions != null)
        {
            if(childPartitions.Count > 0)
            {
                foreach(Partition p in childPartitions)
                {
                    p.parentPartition = this;
                }
            }
        }
        partitionAxes = _partitionAxes;
    }
    public List<Tile> GetTilesInParitition()
    {
        //Get all division axes from parent
        List<PartitionAxes> divisionAxes = new List<PartitionAxes>();
        divisionAxes.Add(partitionAxes);
        Partition currPartition = this;
        Partition parent = currPartition.parentPartition;
        while(parent != null)
        {
            divisionAxes.Add(parent.partitionAxes);
            parent = parent.parentPartition;
        }
        Tile[,] tiles = TileGrid.instance.GetTiles();
        List<Tile> validTiles = new List<Tile>();
        foreach(Tile tile in tiles)
        {
            bool isValid = true;
            foreach(PartitionAxes _axes in divisionAxes)
            {
                if(!TileWithinAxes(tile.GetCoords(),_axes.greaterThanAxis,_axes.axis)){isValid = false;}
            }
            if(isValid){validTiles.Add(tile);}
        }
        return validTiles;
    }
    private bool TileWithinAxes(Vector2Int _coords, bool _greaterThanAxis, Vector2 _axes)
    {
        int x = _coords.x;
        int y = _coords.y;
        if(_greaterThanAxis)
        {
            if(x < _axes.x || y < _axes.y){return false;}
            return true;
        }
        else
        {
            if(x > _axes.x || y > _axes.y){return false;}
            return true;
        }
    }
}
public struct PartitionAxes
{
    public bool greaterThanAxis;
    public Vector2 axis;
    public PartitionAxes(Vector2 _axis, bool _greaterThanAxis)
    {
        axis = _axis;
        greaterThanAxis = _greaterThanAxis;
    }
}

public class Room
{
    public List<Tile> tiles = new List<Tile>();
    private List<Room> connectedRooms = new List<Room>();
    public Tile rootTile;
    public Room(Tile _rootTile)
    {
        rootTile = _rootTile;
    }
    public void AddTiles(List<Tile> _tiles)
    {
        foreach(Tile tile in _tiles)
        {
            if(tiles.Contains(tile)){continue;}
            tiles.Add(tile);
        }
    }
    public void ConnectRoom(Room _room)
    {
        if(_room == this){Debug.Log("Error : Attempted room self connect"); return;}
        if(connectedRooms.Contains(_room)){return;}
        connectedRooms.Add(_room);
    }
    public void DisconnectRoom(Room _room)
    {
        if(!connectedRooms.Contains(_room)){return;}
        connectedRooms.Remove(_room);
    }
    public List<Room> GetConnectedRooms()
    {
        return connectedRooms;
    }
}